(define-macro* cond
  (fn* (x _ _)
       (let ((clauses (rest x)))
         (if (empty? clauses)
             #nil
             (let ((clause  (first clauses))
                   (clauses (rest clauses)))
               `(if ,(first clause)
                    (do ,@(rest clause))
                    (cond ,@clauses)))))))

(define-macro* or
  (fn* (x _ _)
       (let ((clauses (rest x)))
         (cond
          ((empty? clauses) #f)
          ((empty? (rest clauses)) (first clauses))
          (#t `(let ((x ,(first clauses)))
                 (if x x (or ,@(rest clauses)))))))))

(define-macro* and
  (fn* (x _ _)
       (let ((clauses (rest x)))
         (cond
          ((empty? clauses) #t)
          ((empty? (rest clauses))
           (first clauses))
          (#t `(let ((x ,(first clauses)))
                 (if x (and ,@(rest clauses)) x)))))))

(define-macro* when
  (fn* (x _ _)
       (let ((clauses (rest x)))
         `(if ,(first clauses)
              (do ,@(rest clauses))
              #nil))))

(define-macro* unless
  (fn* (x _ _)
       (let ((clauses (rest x)))
         `(if ,(first clauses)
              #nil
              (do ,@(rest clauses))))))

(define-macro* let*
  (fn* (x _ _)
       (let ((x (rest x)))
         (let ((bindings (first x))
               (body     (rest x)))
           (if (empty? bindings)
               `(let () ,@body)
               `(let (,(first bindings))
                  (let* ,(rest bindings) ,@body)))))))

(define-macro* return
  (fn* (x _ _)
       `(return-from #nil (first (rest x)))))

(define-macro* inc!
  (fn* (x _ _)
       `(set! ,(first (rest x))
              (+ ,(first (rest x)) 1))))

(define-macro* dec!
  (fn* (x _ _)
       `(set! ,(first (rest x))
              (- ,(first (rest x)) 1))))

(prn (partition 2 '(a b c d e f g h)))
(prn (partition 3 '(a b c d e f g h i)))

(prn (foldl + '(1 2 3 4 5)))
(prn (foldl + 1 '(2 3 4 5)))
(prn (foldl cons 1 '((1) (2) (3))))

(prn (drop 3 '(1 2 3 4 5 6)))
(prn (take 3 '(1 2 3 4 5 6)))

(prn (take-while even? '(2 4 6 8 10 11 13 15)))
(prn (drop-while even? '(2 4 6 8 10 11 13 15)))

;; will redefine later
;; need it now so that (define func args ... )
;; will expand into (fn args ...) and not (fn* args ...)

(define* not (fn* (x) (if x #f #t)))

(define* rest-sentinel?
  (fn* (x) (and (symbol? x) (eq? x.name ":"))))

(define* not-rest-sentinel?
  (fn* (x) (not (rest-sentinel? x))))

(define* parse-arglist
  (fn* (arglist)
       (let ((pargs (take-while not-rest-sentinel? arglist))
             (rem   (drop-while not-rest-sentinel? arglist)))
         [pargs (first (rest rem))])))

(define* make-restfn
  (fn* (arglist body)
       (let* ((arglist*  (parse-arglist arglist))
              (pargs     (first arglist*))
              (num-pargs (size pargs))
              (rest-var  (first (rest arglist*)))
              (body
               (if rest-var
                   `(let* ((arguments (js* "arguments"))
                           (len       arguments.length)
                           (idx       ,num-pargs)
                           (,rest-var  []))
                      (loop
                       (when (eq? idx len)
                             (return-from #nil))
                       (do (.push ,rest-var (. arguments idx))
                           (inc! idx)))
                      ,@body)
                   `(do ,@body))))
         (prn [pargs rest-var])
         `(fn* (,@pargs) ,body))))

(define-macro* fn
  (fn* (x i c)
       (make-restfn (first (rest x)) (rest (rest x)))))

(define-macro* define
  (fn* (x i c)
      (let ((x (rest x)))
        (if (list? (first x))
            (let ((name (first (first x)))
                  (args (rest  (first x)))
                  (body (rest x)))
              `(define* ,name (fn ,args (block ,name ,@body))))
            `(define* ,(first x) ,(first (rest x)))))))

; We can handle inject/compare via dynamic binding
; for now it's just nice not to suffer through the 
; inexpressive fn* define* and define-macro* forms

(define-macro* define-macro
  (fn (x _ _)
      (let* ((x    (rest x))
             (name (first (first x)))
             (args (rest  (first x)))
             (body (rest x)))
        `(define-macro* ,name
           (let ((transformer (fn (,@args) ,@body)))             
             (fn (x _ _) (apply transformer (rest x))))))))

(define-macro (echo : xs)
  (prn `(do ,@xs))
  `(do ,@xs))

(echo "foo" "bar" "Baz")
